[{"content":"<script>\n  import PreviousNext from \"$lib/components/PreviousNext.svelte\"\n  import Heading from \"$lib/components/Heading.svelte\"\n</script>\n\n<svelte:head>\n    <title>Basics - Vixeny</title>\n    <meta name=\"description\" content=\"about this page\" />\n</svelte:head>\n\n# Introduction\n\nWelcome to Vixeny, a flexible web framework that supports functional programming and other paradigms, providing avenues to success, easy testing, predictable structures, opt-in side effects, performance, safety, readability, and community support. Get started to build extraordinary web applications.\n\n<Heading title=\"Basics\" size=\"2\" />\n\nDefining routes or `Petitions` in Vixeny involves `vixeny(options)([...petitions])`, where options configure the server and petitions are an array of `Petition`.\n\nA \"Hello World\" `Petition` on `\"/\"`:\n```ts\n{\n  path: \"/\",\n  f: () => \"hello world\",\n}\n```\n\n<Heading title=\"Environments\" size=\"2\" />\n\nSetup a basic \"hello world\" server in Bun and Deno as follows:\n\n### In Bun:\n```ts\nimport vixeny from \"vixeny/fun\";\n\nexport default {\n  port: 8080,\n  hostname: \"127.0.0.1\",\n  fetch: vixeny(\n    { hasName: \"http://127.0.0.1:8080/\" }\n    )\n    ([{ path: \"/\", f: () => \"hello world\" }]) \n}\n\n```\n\n### In Deno:\n```ts\nimport { serve } from \"https://deno.land/std/http/server.ts\";\nimport vixeny from \"https://deno.land/x/endofunctor/fun.ts\";\n\nawait serve(\n  vixeny({ hasName: \"http://127.0.0.1:8080/\" })\n    ([{ path: \"/\", f: () => \"hello world\" }]),\n  { port: 8080, hostname: \"127.0.0.1\" },\n);\n```\n\n<Heading title=\"Types\" size=\"2\" />\n\nVixeny has three basic types:\n\n1. **Untyped**: Standard petitions without a `type`. The expecting return type is `BodyInit`.\n   Example:\n   ```ts\n   {\n     path: \"/\",\n     f: () => \"hello world\",\n   }\n   ```\n\n2. **Type Request**: Changes the return type to `Response`, allowing custom status codes and properties.\n   Example:\n   ```ts\n   {\n     path: \"/response/who/:name\",\n     type: \"request\",\n     f: (context) => (context.param.name === \"Bun\" || context.param.name === \"Deno\")\n         ? new Response(\"Welcome\", {status:200})\n         : new Response(\"Only devs here\", {status: 400})\n   }\n   ```\n\n3. **Type Response**: Bypasses the optimizer, directly receiving and returning Request and Response objects, respectively.\n   Example:\n   ```ts\n   {\n     path: \"/response/hello\",\n     type: \"response\",\n     r: r => new Response(\"Hello world!\")    \n   }\n   ```\n\n<Heading title=\"Optimizer\" size=\"2\" />\n\n\nVixeny's optimizer stringifies the given function `f`, analyzes its tokens, and processes only the necessary elements, ensuring speed, safety, and alignment with modern web development best practices.\n\nAdjust this behavior using `add`, `delete`, or `only` in `options`:\n\n- `add` includes additional fields in the arguments.\n- `delete` removes specific fields from the arguments.\n- `only` forces to include only what is required.\n\nExample:\n\n```ts\n{\n  path: \"/\",\n  options:{\n    only: [\"req\"]\n  },\n  f:  context =>  externalFunctionThatNeedsReq(context)\n}\n```\n\n<Heading title=\"Distinctive Features\" size=\"2\" />\n\nVixeny offers unique features like `Resolve` for state setup, `Branch` for conditional execution, `Composing in Context` for cohesive and maintainable code, and `Mutable` for mutable data handling, providing versatility and accommodating various paradigms and preferences.\n\n<PreviousNext next=\"/data_flow\" />\n","route":"/basics"},{"content":"<script>\n    import PreviousNext from \"$lib/components/PreviousNext.svelte\"\n    import Heading from \"$lib/components/Heading.svelte\"\n</script>\n\n<svelte:head>\n    <title>Data Control - Vixeny</title>\n    <meta name=\"description\" content=\"Learn how to manipulate and test data in Vixeny, a functional approach to modern web development.\" />\n</svelte:head>\n\n\n# Data Control\n\nWelcome to the guide on Data Control in Vixeny. Whether you are creating a complex web application or simply want to manage your data more effectively, understanding how to manipulate and test objects is crucial. This guide will walk you through some common techniques for object manipulation and testing with pure functionality in Vixeny. Let's dive in!\n\nThis guide covers Data Control in Vixeny, a modern web development tool. It highlights object manipulation and testing using pure functionality in Vixeny. \n\n<Heading title=\"Object Manipulation\" size=\"2\" />\n\n**Changing Properties**: Use the spread operator (`...`) to create a new object by copying existing properties and overriding the ones you want to change.\n   ```ts\n   const newPetition = { ...existingPetition, path: \"/newRoute\" };\n   ```\n\n<br />\n<br />\n<br />\n\n**Changing and Adding `resolve` and `branch`**: Modify the behavior of a petition or compose new ones by changing or adding `resolve` and `branch`.\n   ```ts\n   resolve: {...r_auth},\n   branch: {...b_auth}\n   ```\n\n<br />\n<br />\n<br />\n\n**Importing and Spreading Petitions**: Import an array of Petitions from other files and add them to your application using the spread operator.\n   ```ts\n   ...petitionsArray\n   ```\n\n<Heading title=\"Testing with Pure Functionality\" size=\"2\" />\n\n**Mocking Async Functions**: Substitute asynchronous functions with synchronous versions that return known values to control behavior and test in isolation.\n   ```ts\n   assertEqual(\n    await petitionComposer()(\n      {\n        ...yourAsyncFunction, \n        resolve: \n        {\n          ...yourAsyncFunction.resolve, \n          f: () => true\n        }\n      }), \n    \"valid\"\n    )\n   ```\n\n### Benefits of Mocking in Functional Programming:\n   - **Isolation**: Replace dependencies with mock implementations to isolate the function being tested.\n   - **Reproducibility**: Create deterministic tests where the same input always produces the same output.\n   - **Ease of Testing**: Eliminate the need to set up and tear down external dependencies.\n\n<Heading title=\"Conclusion\" size=\"2\" />\n\nUnderstanding data manipulation and testing in Vixeny, by embracing functional programming principles and thorough testing, helps in creating robust, maintainable, and efficient applications. For more advanced topics or a deep dive into other features of Vixeny, refer to the complete guide.\n\n<PreviousNext previous=\"data_flow\" next=\"docs\"/>\n","route":"/data_control"},{"content":"<script>\n\timport Iconie from \"$lib/components/Iconie.svelte\";\n    import PreviousNext from \"$lib/components/PreviousNext.svelte\"\n    import Heading from \"$lib/components/Heading.svelte\"\n</script>\n\n<svelte:head>\n\t<title>Data Control - Vixeny</title>\n\t<meta name=\"description\" content=\"About this page\" />\n</svelte:head>\n\n# Data Flow\n\nVixeny provides 3 main tools for controlling data flow: `Resolve`, `Branch`, and `Mutable`.\n\n- `Resolve`: Chains functions, resolving the linked function first and passing its values to the next link.\n- `Branch`: A lazy function to branch out, with its own `context`, `arguments`, `return`.\n- `Mutable`: A mutable object that persists between contexts.\n\nIn Vixeny, functions, methods, and values in **`f`** are unique, and each context is pure unless `Mutable` is used.\n\n<Heading title=\"Resolve\" size=\"2\" />\n\n`resolve`, `petition`, or `branch` can have a `resolve`, which is resolved first and passed to `resolve.NAME`. It applies to `promises` too.\n\n### Sync\n\n```ts\n{\n    path: \"/sync\",\n    resolve: {\n        name: \"nested\",\n        f: context => context.query?.hello ?? \"not found\"\n    },\n    f: context => context.resolve.nested as string\n}\n```\n### Async\n```ts\n{\n    path: \"/async\",\n    resolve: {\n        name: \"nested\",\n        f: async context => await context.req.blob()\n    },\n    f: context => context.resolve.hello as string\n}\n```\nMultiple elements can be resolved at the same time or chained as a pseudo-pipe.\n\n### Benefits\n- `Almost Zero Cost Abstraction`: Efficient code structuring without performance overhead.\n- `Testable`: Pure `petitions` allow reliable testing without external factors.\n- `Composable`: Reuse, modify, and merge `petitions` for a modular codebase.\n\n\n<Heading title=\"Branch\" size=\"2\" />\n\n`branch` creates functions within the `context`, composed by Vixeny, to handle different logic branches.\n\n```ts\n{\n    path: \"/branch\",\n    f: c => c.branch.hello(\"hi\") as string,\n    branch: {\n        name: \"hello\",\n        f: c => c.arguments\n    }\n}\n```\nBranches can interact with the resolve property and be conditional.\n\n### Benefits\n- `Flexibility`: Handle various logical paths seamlessly.\n- `Laziness`: Invoke functions only when needed.\n- `Modularity`: Isolate logic into branches for easier understanding, testing, and maintenance.\n- `Composability`: Interact with functionalities like resolve for elegant solutions.\n\n<Heading title=\"Mutable\" size=\"2\" />\n\nVixeny promotes immutability but provides `mutable` for necessary mutable states.\n\n```ts\n{\n    path: \"/mutable\",\n    mutable: true,\n    resolve: {...example_r_$hello_m_$result_string},\n    f: c => c.mutable.result as string,\n}\n```\n`mutable` is global and works at any code depth.\n\n<Heading title=\"Conclusion\" size=\"2\" />\n\nVixeny's `Resolve`, `Branch`, and `Mutable` allow crafting scalable, efficient, and flexible applications. They balance virtually zero-cost abstraction with the need for mutable states, promoting a robust approach tailored to individual needs. Understanding these core concepts enables writing more composable, testable, and modular Vixeny code, setting developers up for success in current and future projects.\n\n<PreviousNext previous=\"/basics\" next=\"/data_control\" />\n","route":"/data_flow"},{"content":"<script>\n\timport Iconie from \"$lib/components/Iconie.svelte\"\n</script>\n\n<svelte:head>\n    <title>Functional something - Vixeny</title>\n    <meta name=\"description\" content=\"about this page\" />\n</svelte:head>\n# Components\n\nVixeny has many components for simplifying web development, here's a list of them:\n\n## Methods\n- [ üìã Parameters](/docs/modules/parameters)\n- [ üîç Query](/docs/modules/query)\n- [ üç™ Cookies](/docs/modules/cookies)\n- [ üìë Headings](#headings)\n- [ ‚öôÔ∏è Options](#options)\n- [ üìù Stringtify](#stringtify)\n- [ ‚úíÔ∏è Sign](#sign)\n- [ ‚úÖ Verify](#verify)\n\n\n## Data Control\n- [ üõ†Ô∏è Object Manipulation](#object-manipulation)\n- [ üì≤ Set States](#set-states)\n\n\n### Data flow\n- [ üîÑ Resolve](/docs/modules/resolve)\n- [ üîÄ Branch](/docs/modules/branch)\n- [ üîÇ Mutable](/docs/modules/mutable)\n\n<style>\nul {\n    list-style-type: none;\n    padding: 0;\n}\n\na {\nmargin-bottom: 8px;\n}\n\na:hover {\ntext-decoration: underline;\n  }\n</style>\n","route":"/docs"},{"content":"<script>\n    import PreviousNext from \"$lib/components/PreviousNext.svelte\"\n</script>\n\n\n\n<PreviousNext previous=\"/docs\" next=\"/resource/fpBasics\" />\n","route":"/docs/testing"},{"content":"## Branch\n\nAs its name implies, **`branch`** gives us a way to create functions within the `context`, which will be `composed` by Vixeny. These functions are designed to handle different branches of logic.\n\nThe `context` will receive the arguments in `arguments`, and these functions can be **`asynchronous`**. This means you can use asynchronous operations like fetching data or performing calculations without blocking the main thread.\n\nHere's a simple example of using a `branch`:\n\n```ts\n{\n    path: \"/branch\",\n    f: c => c.branch.hello(\"hi\") as string,\n    branch: {\n        name: \"hello\",\n        f: c => c.arguments\n    }\n}\n```\nOr even multiple branches:\n```ts\n{\n    path: \"/branches\",\n    f: c => \n        c.branch.left(\"Hello \") as string + \n        c.branch.right(\"world!\") as string,\n    branch: [\n        {\n            name: \"left\",\n            f: c => c.arguments\n        },\n        {\n            name: \"right\",\n            f: c => c.arguments\n        }\n    ]\n}\n```\n### Interplay with Resolve\nThanks to Vixeny's functional behavior, branches can interact with the resolve property, allowing complex compositions:\n\n```ts\n{\n    path: \"/branch\",\n    f: c => c.branch.hello(\"world!\") as string,\n    branch: {\n        resolve: {\n            name: \"prefix\",\n            f: () => \"hello\"\n        },\n        name: \"hello\",\n        f: c => \n            c.resolve.prefix as string +  \n            c.arguments as string\n    }\n}\n```\nor\n```ts\n{\n    path: \"/branch\",\n    resolve: {\n        name: \"hello\",\n        f: c =>  c.branch.fun(\"hello\"),\n        branch: {\n            name: \"fun\",\n            f: c => c.arguments\n        }\n    },\n    f: c => c.resolve.hello as string,\n}\n```\n### Conditional Branching\nLaziness, an essential concept in functional programming, allows invoking a function only if a condition is fulfilled. Here's an example using branch:\n```ts\n//assuming that the user name will be passed by query\n{\n    path: \"/user/:runtime\",\n    f: c => \n        c.param.runtime === \"bun\"\n            ? c.branch.deno() as string\n            : c.param.runtime == \"deno\"\n                ? c.branch.bun() as string\n                : \"Sorry, we are only working on bun or deno\"\n    branch: [\n        {\n            name: \"bun\",\n            f: c => \n                \"Hello Bun user: \" +\n                c.query?.user ?? \"no user found\"  \n        },\n        {\n            name: \"deno\",\n            f: c => \n                \"Hello Deno user: \" +\n                c.query?.user ?? \"no user found\"  \n        }\n    ]\n}\n```\n### Why Branch?\nBranching in Vixeny brings several key benefits:\n\n- **Flexibility**: You can define a variety of logical paths and handle them seamlessly.\n- **Laziness**: Invoke functions only when needed, improving efficiency.\n- **Modularity**: Isolate specific logic into branches, making your code easier to understand, test, and maintain.\nComposability: Interact with other functionalities like resolve to create complex yet elegant solutions.\nBy embracing the branch feature, developers can achieve greater control and expressiveness in their Vixeny applications, managing the flow of data with precision and elegance.\n\n","route":"/docs/modules/branch"},{"content":"\n## Cookies in Vixeny\n\nIn Vixeny, cookies are used to store user data between multiple requests. You can access the cookies in your function to use them in your response. Let's see how `cookies` work in Vixeny.\n\n### Using Cookies\n\nTo access the cookies in your function, you can use `ctx.cookies`.\n\nFor example:\n\n```typescript\n{\n  path: '/cookies',\n  f: (ctx) => `Your saved name is : ${ctx.cookies?.name || 'default'}`\n}\n```\n\nIn this example, `name` is a cookie that can be accessed in the function using `ctx.cookies.name`, the optimizer will infer the use of `name`\n\n### Multiple Cookies\n\nYou can also include multiple cookies:\n\n```typescript\n{\n  path: '/cookies',\n  f: (ctx) => `Your saved name is : ${ctx.cookies?.name || 'default'} and your saved age is : ${ctx.cookies?.age || 'unknown'}`\n}\n```\n\nIn this example, `name` and `age` are cookies that can be accessed in the function using `ctx.cookies.name` and `ctx.cookies.age`.\n\n### Out of the context \n\nIn this code snippet, a function `greet` is defined outside the route configuration. To access the `cookies` inside the `greet` function, you need to add the `cookies` field to the `ctx` object using the `options` object with the `add` property in the route configuration. This is done by setting `options: { add: [\"cookies\"] }` in the `route` object.\n\n```typescript\nfunction greet(ctx) {\n  return `Hello ${ctx.cookies?.name || 'default'}!`;\n}\n\nconst route = {\n  path: '/route',\n  options: { add: [\"cookies\"] },\n  f: greet\n};\n\nconst route2 = {\n  path: '/route2',\n  options: { add: [\"cookies\"] },\n  f: ctx =>  greet(ctx) \n};\n```\n\n### Using \"only\" Field\n\nYou can also specify which cookies to parse by using the `only` field in the `cookies` object:\n\n```typescript\n{\n  path: '/cookies/onlyName',\n  cookies: {\n    only: [\"name\"]\n  },\n  f: (ctx) => `Hello ${ctx.cookies?.name || 'default'}`\n}\n```\n\nIn this example, only the `name` field is parsed from the cookies, ignoring other fields. Using \"only\" improves significantly the performance.\n\n### Forcing Cookies to be Null\n\nIf you want to force the cookies object in `ctx` to be null, you can use the `remove` property in the `options` object. This will remove the cookies object from `ctx`, and accessing `ctx.cookies` will return `null`.\n\n```typescript\n{\n  path: '/cookies/block',\n  options: {\n    remove: ['cookies']\n  },\n  f: () => \"Hello world\"\n}\n```\n\nIn this example, `ctx.cookies` will always be `null`.\n","route":"/docs/modules/cookies"},{"content":"## Mutable\n\nIn Vixeny, immutability is a core principle. However, there may be situations where mutable state is required. For those cases, Vixeny provides the `mutable` feature.\n\nThe `mutable` property is a powerful tool that can be used when mutable state is necessary. It is neither discouraged nor promoted but offered as a flexible solution to accommodate various needs.\n\nTo use `mutable`, you must declare it at the beginning of the petition, as shown below:\n\n```ts\n{\n    path: \"/mutable\",\n    mutable: true,\n    //  the function is \"example\", resolves with name \"hello\", which mutates \"result\"\n    resolve: {...example_r_$hello_m_$result_string},\n    f: c => c.mutable.result as string,\n}\n```\n\nThe `mutable` object is global and works at any depth within your code:\n\n```ts\n{\n    path: \"/mutable\",\n    mutable: true,\n    //  the function is \"example\", resolves with name \"hello\", which mutates \"result\"\n    resolve: {...example_r_$hello_m_$result_string},\n    f: c => c.branch.function(\"Hello\") as string,\n    branch: {\n        name: \"function\",\n        f: c => c.arguments + c.mutable.result as string\n    }\n}\n```\n\nThis feature is designed for those specific scenarios where mutable state is required. While not a necessity for all Vixeny users, it provides flexibility for a broader range of developers, allowing them to adapt Vixeny to their specific needs and preferences.\n","route":"/docs/modules/mutable"},{"content":"<svelte:head>\n    <title>Functional something - Vixeny</title>\n    <meta name=\"description\" content=\"about this page\" />\n</svelte:head>\n\n## Parameters in Vixeny\n\nIn Vixeny, parameters are variables that you can include in the URL path of your route. These parameters can then be accessed in your function to use them in your response, you also can check how `context` works in: [ >> context](#context)\n\n### Using Parameters\n\nTo include a parameter in your path, you use a colon `:` by default followed by the name of the parameter.\n\nFor example, if you want to create a parameter called `name`, you would include `:name` in your path:\n\n```typescript\n{\n  path: '/param/:name',\n  f: (ctx) => `Hello ${ctx.param.name}`\n}\n```\n\nIn this example, `:name` is a parameter that can be accessed in the function using `ctx.param.name`. \n\n### Example\n\nLet's say you want to create a greeting message using the name provided in the URL. You would create a route like this:\n\n```typescript\n{\n  path: '/hello/:name',\n  f: (ctx) => `Hello ${ctx.param.name}!`\n}\n```\n\nNow, if someone accesses your website with the URL `http://127.0.0.1:8080/hello/John`, the response will be `Hello John!`.\n\n### Multiple Parameters\n\nYou can also include multiple parameters in your path:\n\n```typescript\n{\n  path: '/param/:name/:age',\n  f: (ctx) => `Hello ${ctx.param.name}, you are ${ctx.param.age} years old!`\n}\n```\n\nIn this example, `:name` and `:age` are parameters that can be accessed in the function using `ctx.param.name` and `ctx.param.age`.\n\n### Using External Functions\n\nYou can also define your function outside of the route configuration and then reference it in your route, you can use `options` and check it's behavior in:\n[ >> options](#options)\n\nHere is an example:\n\n```ts\n// Define the function\nfunction greet(ctx) {\n  return `Hello ${ctx.param.name}!`;\n}\n\n// Define the route\nconst route = {\n  path: '/hello/:name',\n  options: { add: [\"param\"] },\n  f: greet\n};\n\n// or\nconst route2 = {\n  path: '/hello/:name',\n  options: { add: [\"param\"] },\n  f: ctx =>  greet(ctx) + \"!\"\n};\n```\n\n\nIn this example, the greet function is defined outside of the route configuration and is then referenced in the f property of the route.\n\n### Forcing Parameters to be Null\n\nIf you want to force the param object in ctx to be null, in this example, you can use the remove property in the `options` object. This will remove the param object from ctx, and accessing ctx.param will return `null`, which triggers the `??` operator to return 'no_param'.\n\n```typescript\n{\n  path: '/hello/:name',\n  options: { remove: [\"param\"] },\n  f: (ctx) =>  ctx.param ?? \"no_param\"\n}\n```\n\nIn this example, `ctx.param` will always be `null` and it will always return `no_param`.\n\n","route":"/docs/modules/parameters"},{"content":"\n## Queries in Vixeny\n\nIn Vixeny, queries are the key-value pairs in the URL after the `?` symbol. These pairs can be accessed in your function to use them in your response. Let's see how `queries` work in Vixeny.\n\n### Using Queries\n\nTo access the query parameters in your function, you can use `ctx.query`.\n\nFor example:\n\n```typescript\n{\n  path: '/query',\n  f: (ctx) => `Your name is : ${ctx.query?.name || 'default'}`\n}\n```\n\nIn this example, `name` is a query parameter that can be accessed in the function using `ctx.query.name` , the optimizer will infer the use of `name`\n\n\n### Multiple Queries\n\nYou can also include multiple query parameters:\n\n```typescript\n{\n  path: '/query',\n  f: (ctx) => `Your name is : ${ctx.query?.name || 'default'} and your age is : ${ctx.query?.age || 'unknown'}`\n}\n```\n\nIn this example, `name` and `age` are query parameters that can be accessed in the function using `ctx.query.name` and `ctx.query.age`.\n\n### Out of the context \n\nIn this code snippet, a function `greet` is defined outside the route configuration. To access the `query` parameters inside the `greet` function, you need to add the `query` field to the `ctx` object using the `options` object with the `add` property in the route configuration. This is done by setting `options: { add: [\"query\"] }` in the `route` object.\n\n```typescript\nfunction greet(ctx) {\n  return `Hello ${ctx.query?.name || 'default'}!`;\n}\n\nconst route = {\n  path: '/route',\n  options: { add: [\"query\"] },\n  f: greet\n};\n\nconst route2 = {\n  path: '/route2',\n  options: { add: [\"query\"] },\n  f: ctx =>  greet(ctx) \n};\n```\n\n\n\n### Using \"only\" Field\n\nYou can also specify which query parameters to parse by using the `only` field in the `query` object:\n\n```typescript\n{\n  path: '/query/onlyName',\n  query: {\n    only: [\"name\"]\n  },\n  f: (ctx) => `Hello ${ctx.query?.name || 'default'}`\n}\n```\n\nIn this example, only the `name` field is parsed from the query, ignoring other fields. Using \"only\" improves significantly the performance.\n\n### Forcing Query to be Null\n\nIf you want to force the query object in `ctx` to be null, you can use the `remove` property in the `options` object. This will remove the query object from `ctx`, and accessing `ctx.query` will return `null`.\n\n```typescript\n{\n  path: '/query/block',\n  options: {\n    remove: ['query']\n  },\n  f: () => \"Hello world\"\n}\n```\n\nIn this example, `ctx.query` will always be `null`.\n","route":"/docs/modules/query"},{"content":"\n## Resolve\nIf a `resolve`, the `petition`, or `branch` has a `resolve`, this function will be resolved first and passed to `resolve.NAME`. This also applies to `promises`.\n### Sync\n```ts\n{\n    path: \"/sync\",\n    resolve: {\n        name: \"nested\",\n        f: context => context.query?.hello ?? \"not found\"\n    },\n    //\"nested\" is accessible to \"context\"\n    f: context => context.resolve.nested as string\n}\n```\n### Async\n```ts\n{\n    path: \"/async\",\n    resolve: {\n        name: \"nested\",\n        //the blob is created before reaching the next step of the chain\n        f: async context => await context.req.blob()\n    },\n    //this function is sync because of the way Vixeny unwraps and resolves\n    f: context => context.resolve.hello as string\n}\n```\nAlso, you can resolve many elements at the same time.\n\n```ts\n{\n    path: \"/multiple\",\n    resolve: [\n        {\n            name: \"blob\",\n            f: async context => await context.req.blob()\n        },\n        {\n            name: \"query\",\n            f: context => context.query?.hello ?? \"no query\"\n        },\n    ],\n    f: f => f.resolve.blob\n            ? \"your query is: \" + f.resolve.query as string\n            : \"no body\"\n}\n```\nOr you can `chain` them as a pseudo-pipe.\n```ts\n{\n    path: \"/nested/:id\",\n    //nested resolve that response (response)\n    resolve: {\n        name: \"response\",\n        //nested resolve that response (param)\n        resolve: {\n            name: \"param\",\n            f: context =>  \" id : \" + context.param.id\n        },\n        f : context => \" query :\" + (context.query?.hello ?? \" no query \")\n            + context.resolve.response as string\n    },\n    f:  context => context.resolve.response as string\n}\n```\n\nSo why do we need them? These functionalities are not merely a way to organize code; they represent a robust approach to crafting scalable and maintainable applications. By isolating code and creating powerful and customizable plugins, you're not only enhancing the current development process but also building a foundation that can easily adapt and grow with future needs.\n\n- **`Almost Zero Cost Abstraction`**: These compositions don't really hurt performance, and in some cases, they're even faster. This efficiency means that you can structure your code in a way that makes sense to you without worrying about the overhead.\n- **`Testable`**: As we will explore later, you can test your `petitions` in a pure form, where there's no need for databases or any external factors outside of Vixeny. This isolation makes testing more reliable and straightforward.\n- **`Composable`**: Treating `petitions` as values allows you to reuse, modify, and merge them at your will. This composability fosters a more modular and adaptable codebase, enabling you to easily tweak or expand functionality.","route":"/docs/modules/resolve"},{"content":"<script>\n\timport PreviousNext from \"$lib/components/PreviousNext.svelte\"\n</script>\n\n<svelte:head>\n    <title>Functional something - Vixeny</title>\n    <meta name=\"description\" content=\"about this page\" />\n</svelte:head>\n\n# hello\n\nhello\n\n\n<PreviousNext previous=\"/docs/testing\" />\n","route":"/resource/fpBasics"}]