[
  {
    "url": "/framework/init",
    "content": "<script>\n    import Tabs from \"$lib/components/Tabs.md\"\n    import Bash from \"$lib/components/SmallComponents/Bash.md\"\n\n    const tab1 = [\n        {title: \"Bun\", component: Bash, details: {runtime: \"bun\"}},\n        {title: \"Deno\", component: Bash, details: {runtime: \"deno\"}}\n    ]\n</script>\n<svelte:head>\n    <title>Quick start - Vixeny</title>\n    <meta name=\"description\" content=\"How to install Vixeny\" />\n</svelte:head>\n\n# Quick start\n\nHere's how to start\n\n<Tabs data={tab1}/>\n\n\n"
  },
  {
    "url": "/framework/routing",
    "content": "<svelte:head>\n    <title>Routing - Vixeny</title>\n    <meta name=\"description\" content=\"Learn how to create routes in Vixeny\" />\n</svelte:head>\n\n# Routing\nRouting is the most important thing, check this out\n\n## Introduction\n\nIn the `versatile` world of JavaScript, wrap plays a key role in harmonizing the language's polymorphic nature with Vixeny's functional approach. It ensures scalability and maintains code purity, crucial for efficient web development.\n\n```ts\n// name of this file: api.ts\nimport { wrap } from \"vixeny\";\n//routing options\nimport { options } from \"somewhere.ts\"; \n\nconst api = wrap({\n  //setting up options\n  ...options,\n  startWith: \"/api\",\n})()\n//creating a petition\n  .stdPetition({\n    path: \"/ping\",\n    f: () => \"pong\",\n  })\n\nexport { api }\n```\n\nSimplifing handling diverse HTTP requests, offering a structured, side-effect-free programming environment. This makes building, maintaining, and scaling web applications more intuitive and manageable, showcasing wrap as an essential tool in the Vixeny toolkit.\n\n```ts\nimport { wrap, vixeny } from \"vixeny\";\nimport { options } from \"somewhere.ts\"; \nimport { api } from \"api.ts\"; \n\nconst router = wrap(options)()\n  .stdPetition({\n    path: \"/\",\n    f: () => \"hello world\",\n  })\n  //joining `api` to this wrap\n  .union(api.unwrap())\n  // console logging:\n  // outputs: '/'\n  //          '/api/ping'\n  .logPaths()\n\n// unwrapping all the petitions giving them to the router\nvixeny(options)(router.unwrap())\n```\n## Petitions\n\nLet's create a Petition without wrap and export it an create new differents routes out of it.\n\n```ts\nimport { Petition } from \"vixeny/optimizer/types\";\n\nconst surprise: Petition = {\n    path: \"/meow\",\n    headings: {\n        status: 307,\n        statusText: \"Temporary Redirect\",\n        headers: {\n            Location: \"https://www.youtube.com/watch?v=_e9yMqmXWo0\"\n        }\n    },\n    f: (c) => \"\"\n}\n\nexport { surprise }\n```\nIn another file:\n\n```ts\nimport { surprise }  from 'somewhere.ts'\n\nexport default wrap(options)()\n  .stdPetition(surprise)\n  .stdPetition({...surprise, path: '/woof'})\n  .stdPetition({...surprise, path: '/woooow'})\n  // console logging:\n  // outputs: '/meow'\n  //          '/woof'\n  //          '/woooow'\n  .logPaths()\n```\n\nApplies to any other key in the object.\n\n## Types\n\n There are two type of petitions:\n  - `stdPetition`: where you have to return a `BodyInt` or `Promise<BodyInt>`\n  - `customPetition`: where you have to return a `Response` or `Promise<Response>`\n\n```ts\nwrap(options)()\n  .stdPetition({\n    path: \"/\",\n    f: () => \"hello world\",\n  })\n  .customPetition({\n    path: \"/response/who/:name\",\n    f: (c) =>  new Response(c.param.name)\n  })\n```\n\nIt is important to note that `wrap` only supports these types although there are more types which serve different purposes which must be directly inserted.\n\n```ts\nvixeny(options)([\n    //importing all the paths\n    ...wrap(options)()\n      .union(root.unwrap())\n      .union(api.unwrap())\n      .unwrap(),\n    //adding the static server\n    {\n      type: \"fileServer\",\n      path: \"./public/\",\n      name: \"/public/\",\n    },\n    // petition without ctx\n    {\n      path: \"/responseType\",\n      type: \"response\",\n      r: () => new Response('Hello')\n    }\n  ])\n```\n\n"
  },
  {
    "url": "/framework/wrap",
    "content": "\n<svelte:head>\n    <title>Wrap - Vixeny</title>\n    <meta name=\"description\" content=\"Understanding wrap\"/>\n</svelte:head>\n\n# Wrap\n\nHello peepol\n\n### Union\n\nOne of the most important uses of `wrap` in Vixeny is to protect and modularize `Petitions`, especially when they are exported or modified. This ensures that your code remains organized and maintainable. Let's demonstrate this with an example involving multiple files:\n\nFirst, create a file named `extension.ts`:\n\n```ts\n//file: extension.ts\nexport default wrap()()\n  .stdPetition({\n    path: \"/\",\n    f: () => \"helloWorld\",\n  })\n```\n\nNext, create two separate files, `a.ts` and `b.ts`, which import and utilize `extension.ts`:\n\n```ts\nimport extension from \"./extension.ts\"\n\n// file: a.ts\nexport default wrap()()\n    .union(extension.unwrap())\n    .stdPetition({\n    path: \"/hello\",\n    f: () => \"helloWorld\"\n    })\n    // console logging\n    // outputs: \"/\"\n    //          \"/hello\"\n    .logPaths()\n\n```\n\n```ts\nimport extension from \"./extension.ts\"\n\n// file: b.ts\nexport default wrap()()\n    .union(extension.unwrap())\n    .stdPetition({\n    path: \"/api\",\n    f: () => \"helloWorld\"\n    })\n    // console logging\n    // outputs: \"/\"\n    //          \"/api\"\n    .logPaths()\n```\nAdditionally, you can add `extension` to its second curried function (`wrap()(here)`) and modify the `base`. This allows for further customization of the routing:\n\n```ts\nimport extension from \"./extension.ts\"\n\nexport default wrap()(\n    extension.union(\n        // changing the start path of the wrap `extension`\n        extension.changeOptions({ \"startWith\": \"/api\" })\n        .unwrap(),\n    ))\n    .stdPetition({\n        path: \"/\",\n        f: () => \"helloWorld\",\n    })\n    // console logging\n    // outputs: \"/api/\"\n    //          \"/\"\n    .logSize()\n```\n\n### Optimizer\n\nIn Vixeny, the `optimizer` is a crucial function that oversees the `CTX` in `f`, composes the petition, chains `resolve` and `branch`, and efficiently handles all asynchronous and synchronous functions. But what does this mean? Let's first explore the `CTX`, which in TypeScript shows you all the native functions (including plugins, which are not included here):\n\n - `\"req\"`: Gives access to the `Request`.\n - `\"query\"`: Retrieves the query parameters.\n - `\"param\"`: Fetches the URL parameters.\n - `\"date\"`: Returns the current date.\n - `\"randomNumber\"`: Generates a random number from 0 to 1.\n - `\"hash\"`: Produces a random hash (string).\n - `\"cookie\"`: Accesses cookies.\n - `\"resolve\"`: Resolves any `morpishim` before the execution of the current `CTX`.\n - `\"branch\"`: A function within `CTX` that is also a `morpishim` and it has its own `CTX`.\n - `\"mutable\"`: Adds a fixed point to all `morpishim` in the `petition`, regardless of depth.\n - `\"arguments\"`: Arguments passed to `branch`.\n - `\"token\"`: (requires `crypto`) Checks and parses a cookie with the given key.\n - `\"sign\"`: (requires `crypto`) Signs a JSON.\n - `\"verify\"`: (requires `crypto`) Verifies and parses a string.\n\nHowever, none of these are actually included in the `CTX` by default. The `Optimizer` analyzes (tokenizes `f` and checks for the keys used) your petition and adds only what's required. If there's nothing required, it simply handles the `Request`.\n\n```ts\nexport default wrap()()\n  .stdPetition({\n    path: \"/\",\n    f: () => \"helloWorld\",\n  })\n    // console logging\n    // outputs: []\n  .logLastCheck()\n  .stdPetition({\n    path: \"/hello/:id\",\n    f: c => c.param.id,\n  })\n    // console logging\n    // outputs: [\"param\"]\n  .logLastCheck()\n```\n\nThere are some limitations to this, for example, the optimizer cannot understand what functions outside of the context need, but you can manually add them:\n\n```ts\nexport default wrap()()\n  .stdPetition({\n    path: \"/hello/query1\",\n    f: c => functionOutsideOfContext(c),\n  })\n    // console logging\n    // outputs: []\n  .logLastCheck()\n  .stdPetition({\n    path: \"/hello/query2\",\n    f: c => functionOutsideOfContext(c),\n    options:{\n      add: ['query']\n    }\n  })\n    // console logging\n    // outputs: [\"query\"]\n  .logLastCheck()\n```\n\nYou have three options for customization:\n- `only`: Bypasses the optimizer, adding only the requested functions.\n- `add`: Adds specified functions to the list.\n- `remove`: Removes a function if it is added but not required, which could happen but is harmless to the `CTX`.\n\n"
  },
  {
    "url": "/framework/morphism",
    "content": "\n<svelte:head>\n    <title>Morphism - Vixeny</title>\n    <meta name=\"description\" content=\" understanding morphism\" />\n</svelte:head>\n\n\n# Morphism\n\nImagine Vixeny guiding you through the process of crafting your dream home, simplifying the complexities of web development into something straightforward and manageable. It employs two key concepts `Resolve` and `Branch` much like the essential steps in building a house, laying the foundation and then expanding upon it to add the final touches.\n\n## Foundations First: Resolve\n\n`Resolve` prepares your site, organizing all the essentials before construction starts. It's like getting the land ready, ensuring materials are on-site. This includes setting up data and permissions in advance, guaranteeing that when it's time to build, everything's in place.\n\n## Adding Features: Branch\n\nOnce the basics are set, `Branch` lets you customize, adding unique features to your site. Think of it as choosing room designs or adding a garden, enhancing your home's functionality and appeal without starting over.\n\n## Building with Intention: The Vixeny Way\n\nVixeny’s approach mirrors thoughtful home construction, emphasizing:\n\n- **Reusability**: Modular design lets you replicate and adapt features easily, akin to using a beloved room design throughout your home.\n- **Purity**: Ensuring operations are clean and predictable, much like choosing quality materials for your home, Vixeny keeps your project stable and reliable.\n- **Testing for the Future**: Mocking tests different scenarios, preparing your site for future needs—just as planning for potential home additions or changes.\n\n\n## Morphism\n\n### Resolve and Branch\n\nNow, let's talk more about the Optimizer in Vixeny; after identifying all necessary functions, orchestrates the composition of petitions. This process intricately weaves together all resolves and branches, both of which are considered types of morphisms. Interestingly, a petition in itself is conceptualized as a morphism. This highlights the functional and compositional core of Vixeny, where both resolves and branches play pivotal roles:\n\n## Resolve\n\n- **Definition**: In any morphism, a `resolve` guarantees its resolution prior to the execution of the petition's main function (`f`).\n\n  ```ts\n  wrap(options)()\n    .stdPetition({\n      path: \"/withResolve\",\n      resolve: {\n        // The key name here can be any string\n        hi: { c: () => \"Hello world\" }\n      },\n      // This petition consistently outputs \"Hello world\"\n      f: (c) => c.resolve.hi,\n    })\n  ```\n\n- **Asynchronous Functions**: Asynchronous resolves maintain the state of the morphism, meaning the asynchronous result is merged without altering the original state.\n\n  ```ts\n  wrap()()\n    .stdPetition({\n      path: \"/withResolveAsync\",\n      resolve: {\n        hi: { async c: () => await Promise.resolve(\"Hello world\") }\n      },\n      // Note: The function in `f` is synchronous\n      f: (c) => c.resolve.hi,\n    })\n  ```\n\n- **Execution Order**: All resolves are executed and completed prior to their integration into the `CTX`, ensuring their resolved outputs are accessible within the `CTX` for the petition's logic.\n\n  ```ts\n  wrap(options)()\n    .stdPetition({\n      path: \"/helloWorld\",\n      resolve: {\n        hello: { async f: () => await Promise.resolve(\"Hello\") }, \n        world: { f: () => 'world' }\n      },\n      f: c => `${c.resolve.hello} ${c.resolve.world}`,\n    })\n  ```\n\n- **Uniqueness of `CTX`**: With the exception of `mutable`, each `CTX` instance remains unique and isolated, ensuring petitions remain decoupled.\n\n  ```ts\n  wrap(options)()\n  .stdPetition({\n    path: \"/date\",\n    resolve: {\n      date: morphism(o)({ f : c => c.date })\n    },\n    f: c => c.resolve.date !== c.date\n        ? 'Always true'\n        : 'Unreachable'\n  })\n  ```\n\n- **Nested Resolves and Branches**: Vixeny supports an unlimited nesting of resolves and branches within each other.\n\n  ```ts\n  const hello = morphism(options)({\n    resolve: {\n      nestedHello: {\n        f: () => \"hello world\"\n      },\n    },\n    f: (c) => c.resolve.nestedHello,\n  });\n\n  wrap(options)()\n    .stdPetition({\n      path: \"/hello\",\n      resolve: {\n        hello: hello\n      },\n      f: (c) => c.resolve.hello,\n    })\n  ```\n\nIn Vixeny, `f` stands for `functor`, because: `functor preserve structure`. This concept underscores how resolves and the main function interact while maintaining the integrity of the petition's structure.\n\n\n### Branch\n\nIn Vixeny, a `Branch` is used to incorporate additional logic or operations within the execution of a petition,which has its own `CTX`. Branches, like resolves, are morphisms but are specifically designed to execute alongside or within the main function (`f`) of a petition, offering a direct way to extend functionality without cluttering the primary logic.\n\n\n### 1. Defining a Simple Branch\n\nA branch can be as simple as a function that returns a static message. This example demonstrates how to define and use a simple branch within a petition:\n\n```ts\nconst helloBranch = morphism(options)({\n  f: (c) => \"Hello from branch\",\n});\n\nwrap(options)()\n  .stdPetition({\n    path: \"/helloBranch\",\n    branch: {\n      hello: helloBranch,\n    },\n    f: (c) => new Response(c.branch.hello(null)),\n  })\n```\n\n- **Explanation**: Here, `helloBranch` is defined as a morphism with a function (`f`) that returns a static string. Within the petition, this branch is invoked, and its return value is used to construct a response.\n\n### 2. Branch with Parameters\n\nBranches can also accept parameters, making them dynamic in their operation. This example illustrates a branch that utilizes parameters from the `CTX`:\n\n```ts\nconst greetUserBranch = morphism()({\n  f: (c) => `Hello, ${c.arguments.name}`,\n});\n\nwrap(options)()\n  .stdPetition({\n    path: \"/greet/:name\",\n    branch: {\n      greetUser: greetUserBranch,\n    },\n    f: (c) => new Response(c.branch.greetUser({ name: c.param.name })),\n  })\n```\n\n- **Explanation**: `greetUserBranch` takes a name parameter through `c.arguments` and returns a personalized greeting. The branch is executed in the petition's main function, using the name parameter extracted from the URL.\n\n### 3. Asynchronous Branch\n\nBranches can perform asynchronous operations, such as fetching data from a database or an external API:\n\n```ts\nconst fetchUserDataBranch = morphism(options)({\n  async f: (c) => {\n    const userId = c.arguments.userId;\n    return await fetch(`https://api.example.com/users/${userId}`).then(res => res.json());\n  },\n});\n\nwrap(options)()\n  .stdPetition({\n    path: \"/user/:userId\",\n    branch: {\n      fetchUserData: fetchUserDataBranch,\n    },\n    f: async (c) => {\n      const userData = await c.branch.fetchUserData({ userId: c.param.userId });\n      return new Response(JSON.stringify(userData));\n    },\n  })\n```\n\n### Explaining `Mutable` in Context\n\n\n- **Mutability Concept**: In this scenario, `Mutable` refers to the ability of the context (`c`) to have its state changed and those changes preserved across subsequent transformations or operations.\n\n- **Implementation with `mutStdPetition`**: By using `mutStdPetition`, adds the key `mutable` which persistent. This allows subsequent operations or morphisms to access and further modify the updated state. Specifically, any property added to `c.mutable` becomes a preserved state that can be referenced or altered in later stages of processing.\n\n### Practical Example\n\n```ts\n// Initial operation with mutStdPetition, introducing a mutable context\n.mutStdPetition({\n  // Configuration and initial transformation\n  resolve: {\n    // Use morphism to modify and use the mutable state\n    randomNumber: morphism(options)({ f : c => \n    { \n      c.mutable.randomNumber = c.randomNumber; \n      return c.randomNumber; \n      } \n    )\n  },\n  // Subsequent operation accessing and evaluating the mutable state\n  f: c => c.mutable.randomNumber !== c.randomNumber\n      ? 'Condition based on mutable state'\n      : 'Potentially reachable if state matches'\n})\n```\n\nIn this example, `c.mutable.randomNumber` is set in one operation, and this state is then available for comparison in the next operation. This demonstrates how `Mutable` allows for complex, state-dependent logic to be implemented across a sequence of morphisms, leveraging the state preserved in `c.mutable`.\n\nIt's important to notice that `mutStdPetition` and `stdPetition` are composed differently and a pure state like `stdPetition` is totally independent of `mutStdPetition`\n\n\n\n\n### Purpose of morphism\n\n`morphism` functions are designed to facilitate explicit data transformation in a type-safe manner, especially useful in scenarios where TypeScript's type inference capabilities are stretched thin by deep nesting or complex operations. By breaking down transformations into manageable, clearly defined steps, `morphism` ensures that each operation is both comprehensible and type-safe.\n\n### TypeScript's Typing Limitation\n\nTypeScript's type system, while robust, cannot always effectively manage or infer types in deeply nested or highly complex transformations. This limitation can lead to challenges in enforcing type safety, particularly in applications that require detailed manipulation of nested data structures.\n\n\n### Practical Application\n\nTo explain the provided code snippets effectively, let's break down the concept of morphisms as used here, especially \n\n\n#### Hello Morphism\n\nThe first morphism, `hello`, is defined to perform no direct transformation but specifies a nested `resolve` structure with a static value and a function that returns a string \"hello\". The final function `f` extracts the `nested` part of the resolved structure.\n\n```ts\nconst hello = morphism(options)({\n  resolve: {\n    //resolves first\n    nested: {\n      crypto: {\n        globalKey: 'your secret'\n      },\n      f: () => \"hello\",\n    },\n  },\n  // showing inference from a nested resolve\n  f: (f) => f.resolve.nested,\n});\n```\n\n#### NestedHello Morphism\n\nThe `nestedHello` morphism wraps the `hello` morphism within its `resolve`, showing how morphisms can be nested or chained to build upon the results of previous transformations.\n\n```ts\nconst nestedHello = morphism(options)({\n  resolve: {\n    hello: hello,\n  },\n  // showing inference from a nested resolve\n  f: (f) => f.resolve.hello,\n});\n```\n\n#### isValidUser Morphism\n\nThis morphism validates a JWT token by checking if it exists and if its `iat` (issued at time) is before the current time. It showcases how to perform conditional checks within a morphism.\n\n```ts\nconst isValidUser = morphism(options)({\n  crypto: {\n    globalKey: 'your secret',\n    token: {\n      jwtToken: {},\n    },\n  },\n  f: c => c.token.jwtToken && (c.token.jwtToken as {name:string,iat:number}).iat < Date.now()\n    ? c.token.jwtToken\n    : null\n});\n```\n\n#### Please Morphism\n\nFinally, the `check` morphism demonstrates how to resolve dependencies using previous morphisms (`isValidUser`) and process the result further.\n\n```ts\nconst please = morphism(options)({\n  resolve: {\n    check: isValidUser\n  },\n  f: c => c.resolve.check !== null \n    ? 'Valid token'\n    : 'Invalid token'\n});\n```\n\n### Key Concepts\n\n- **Branching and Resolving**: These operations allow for the construction of complex data transformation pipelines. Branching can be seen as defining various paths of data flow and logic, while resolving handles the actual execution of these paths to produce a final outcome.\n- **Modularity**: Morphisms can be nested and reused, promoting modularity and reuse of logic.\n- **Declarative Logic**: The structure allows for a clear, declarative definition of data transformations and conditions, improving readability and maintainability.\n\n"
  },
  {
    "url": "/framework/test",
    "content": "## Testing: The Keystone of Digital Construction\n\nIn building, thorough testing and inspections are non-negotiable, ensuring every part of the structure meets exacting standards. Vixeny embeds this principle deeply within its framework, offering a comprehensive testing suite that simulates various scenarios, ensuring every component functions as intended.\n\n### Case Study: Simulating Conditions\n\nImagine a feature in our digital architecture that responds to environmental changes, much like a smart home system adjusting to weather variations. Vixeny enables us to test these dynamic responses, ensuring they act precisely under varied simulated conditions.\n\n#### Scenario: Predicting Outcomes\n\nOur focus falls on a `/random` feature, designed to yield different outcomes based on a random number generator. This setup mirrors real-life scenarios where outcomes pivot on user interactions or external data.\n\n```ts\nconst routes = wrap(options)()\n  .stdPetition({\n    path: \"/random\",\n    f: (c) =>\n      c.randomNumber > .5\n        ? c.randomNumber > .99 ? \"winner\" : \"almost\"\n        : \"try again\",\n  });\n```\n\n#### Crafting the Tests\n\nTo ensure our feature behaves predictably across a range of states, we manipulate the random number generator, crafting scenarios to test the anticipated outcomes.\n\n```ts\ntest(\"/random\", async () => {\n  // Testing for the \"try again\" outcome.\n  expect(\n    await routes\n      .handleRequest(\"/random\")({\n        options: {\n          setRandomNumber: .25,\n        },\n      })(new Request(\"/random\"))\n      .then((res) => res.text()),\n  ).toStrictEqual(\"try again\");\n\n  // Testing for the \"almost\" outcome.\n  expect(\n    await routes\n      .handleRequest(\"/random\")({\n        options: {\n          setRandomNumber: .51,\n        },\n      })(new Request(\"/random\"))\n      .then((res) => res.text()),\n  ).toStrictEqual(\"almost\");\n\n  // Testing for the \"winner\" outcome.\n  expect(\n    await routes\n      .handleRequest(\"/random\")({\n        options: {\n          setRandomNumber: .999,\n        },\n      })(new Request(\"/random\"))\n      .then((res) => res.text()),\n  ).toStrictEqual(\"winner\");\n});\n```\n\n### Refining the Process with Mocked Resolves\n\nFor a feature reliant on external APIs, like fetching current weather data, we aim to test without real-time data fetches. Here, we introduce a mocked synchronous function to simulate the data fetching:\n\n```ts\n// Original asynchronous resolve function for fetching weather data\nconst routes = wrap(options)()\n  .stdPetition({\n    path: \"/weather\",\n    resolve: {\n      currentWeather: {\n        async f: () => {\n          return await fetch(\"https://api.weather.com/current\").then(res => res.json());\n        }\n      }\n    },\n    f: (c) => {\n      return c.resolve.currentWeather.temperature > 75 ? \"It's warm outside\" : \"It's cool outside\";\n    },\n  });\n\n// Mocking the resolve function for controlled testing\nconst mockedWeatherResolve = () => ({ temperature: 80 });\n\n// Injecting the mocked resolve using handleRequest\nconst mockRoutes = routes.handleRequest(\"/weather\")({\n  resolve: {\n    currentWeather: mockedWeatherResolve\n  }\n});\n\n// Verifying behavior with the mocked data\ntest(\"/weather\", async () => {\n  expect(\n    await mockRoutes(new Request(\"/weather\"))\n      .then(res => res.text())\n  ).toStrictEqual(\"It's warm outside\");\n});\n```\n\n### The Virtues of Mocked Testing\n\nThis approach grants us unparalleled control over the testing environment, mirroring the precision and adaptability seen in the most advanced construction methodologies. It allows for:\n\n- **Precision and Predictability**: Creating a controlled environment that simulates specific conditions, ensuring components react as expected.\n- **Efficiency**: Streamlining the testing process by removing dependencies on external data sources.\n- **Confidence**: Providing assurance in the reliability and functionality of the digital structure, much like the final inspection before a home's completion.\n\n## Conclusion: Building Digital Foundations with Assurance\n\nJust as thorough inspections ensure a home is ready for habitation, Vixeny's testing capabilities, particularly the use of mocked resolves, ensure that every digital component is built to perfection. This meticulous approach to testing empowers developers to construct with confidence, knowing every part of the application is crafted to meet and exceed expectations, ensuring a robust, functional, and adaptable digital experience. Through Resolve, Branch, and precise testing, Vixeny lays the groundwork for web applications that stand the test of time, embodying the principles of a well-constructed home.\n\n\nThank you for your time."
  },
  {
    "url": "/framework/plugins",
    "content": "# Plugins\n\nPlugins are a way of extending Vixeny and adding some abstractions for your beloved patterns, libraries.\n\n## Official plugins\n\n<a href=\"#\" target=\"_blank\">Link 1</a>\n<a href=\"#\" target=\"_blank\">Link 1</a>\n<a href=\"#\" target=\"_blank\">Link 1</a>\n\n## Community plugins\n\n<a href=\"#\" target=\"_blank\">Link 1</a>\n<a href=\"#\" target=\"_blank\">Link 1</a>\n<a href=\"#\" target=\"_blank\">Link 1</a>\n\n<style>\na { margin-block: 8px; }\n</style>\n"
  }
]
