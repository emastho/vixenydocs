[
  {
    "url": "/framework/init",
    "content": "<script>\r\n    import Tabs from \"$lib/components/Tabs.md\"\r\n    import Bash from \"$lib/components/SmallComponents/Bash.md\"\r\n    import example0 from \"$lib/examples/intro_core_0.md\"\r\n    import example1 from \"$lib/examples/intro_core_1.md\"\r\n    import example2 from \"$lib/examples/intro_core_2.md\"\r\n    import example3 from \"$lib/examples/intro_core_3.md\"\r\n\t  import example4 from \"$lib/examples/intro_core_4.md\"\r\n    import FancyLink from '$lib/components/FancyLink.svelte';\r\n    const install = [\r\n        {title: \"Bun\", component: Bash, details: {runtime: \"bun\"}},\r\n        {title: \"Deno\", component: Bash, details: {runtime: \"deno\"}}\r\n    ]\r\n    const tab0 = [\r\n        {title: \"main.ts\", component: example0, details: {runtime: \"main\"}},\r\n        {title: \"setup.ts\", component: example0, details: {runtime: \"setup\"}}\r\n    ]\r\n\r\n    const tab1 = [\r\n        {title: \"main.ts\", component: example1, details: {runtime: \"main\"}},\r\n        {title: \"setup.ts\", component: example1, details: {runtime: \"setup\"}}\r\n    ]\r\n\r\n    const tab2 = [\r\n        {title: \"main.ts\", component: example2, details: {runtime: \"main\"}},\r\n        {title: \"setup.ts\", component: example2, details: {runtime: \"setup\"}}\r\n    ]\r\n\r\n    const tab3 = [\r\n        {title: \"main.ts\", component: example3, details: {runtime: \"main\"}},\r\n        {title: \"setup.ts\", component: example3, details: {runtime: \"setup\"}}\r\n    ]\r\n\r\n\tconst tab4 = [\r\n        {title: \"main.ts\", component: example4, details: {runtime: \"main\"}},\r\n        {title: \"setup.ts\", component: example4, details: {runtime: \"setup\"}}\r\n    ]\r\n</script>\r\n\r\n<svelte:head>\r\n    <title>Quick Start with Vixeny Framework - Installation and Examples</title>\r\n    <meta name=\"description\" content=\"Learn how to quickly start with the Vixeny framework. Find installation guides and code examples for Bun and Deno runtimes.\" />\r\n    <meta name=\"keywords\" content=\"Vixeny, web development, framework, installation, Bun, Deno, JavaScript, TypeScript, coding examples, petitions, wrap function, functional programming, reusable code\" />\r\n    <meta name=\"author\" content=\"Vixeny Team\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\r\n    <script src='/prism.mjs'></script>\r\n</svelte:head>\r\n\r\n# Welcome to Vixeny!\r\n\r\nWe’re thrilled to have you explore our framework. Vixeny is all about making web development straightforward and enjoyable, no matter your background in coding. Whether you're just starting out or looking to shift into a new style of programming, we’ve designed Vixeny to be as welcoming as possible.\r\n\r\n## So, What's this project?\r\n\r\nAn ecosystem of functional web tools, that aims to make code more:\r\n\r\n- `Open` : All our tools are exportable and can be used in other frameworks or \r\n  projects.\r\n\r\n- `Reusable` : Make it once and use it again, because of the purity of `Vixeny`,\r\n  every element can be reused and composed in many ways.\r\n\r\n- `Testable` : Thanks to its monolithic structure, it can be tested in any state.\r\n\r\n- `Smart` : Asyncronless with an integrated system that helps you to detect bugs\r\n  and optimize your code on the fly.\r\n\r\n- `Safe and maintainable` : Everything is deterministic, and its object-based\r\n  structure allows the maintainers to easily add things without needing to push\r\n  broken code changes.\r\n\r\n- `Fast` : Holding the record of being the fastest framework when it comes to\r\n  `(r: Request) => Response | Promise<Response>` handlers innot only Deno but\r\n  also Bun.\r\n\r\n## How?\r\n\r\nActually, it all boils down to the functional paradigm, but let's keep things straightforward. Vixeny was crafted with friendliness in mind for everyone! So, you won’t be bogged down by complex tutorials on functional programming. Instead, you’re here to explore the flexibility and to apply it wherever it suits your needs.\r\n\r\n## Why `Vixeny`?\r\n\r\nVixeny's name comes from seeing her like a style of coding, it's not difficult\r\nto learn but different and rewarding, focusing more on the flow of your code,\r\nwith that unique ability to see everything at any point with full transparency.\r\n\r\nNow, without further ado, let's embark on your journey from 'zero to hero' with Vixeny!\r\n\r\n## Quick start\r\n\r\nThe best way to dive into Vixeny is by jumping straight into examples. Feel free to copy and run any of the examples provided. Designed to be backward compatible and runtime agnostic, Vixeny ensures that code you write today will continue to work seamlessly in the future, whether you're using Deno, Bun, or any other environment.\r\n\r\nTo get started, you can install our fully-equipped templates from the links below:\r\n\r\n<Tabs data={install}/>\r\n\r\n\r\nIt's recommended to learn how the template engine  works, via the link below.\r\n\r\n>  [Template engine](/perspective/create-vixeny)\r\n\r\nEnjoy exploring and have fun coding!\r\n\r\n\r\n## Petitions\r\n\r\nIn Vixeny, routes are referred to as `petitions`. These are objects that\r\nnecessitate a function, denoted as `f`, and a `path`. The example below\r\nillustrates how to define a basic petition:\r\n\r\n```javascript \r\nimport { petitions } from \"vixeny\";\r\n\r\n// Returning a `BodyInit`\r\nconst helloWorld = petitions.common()({\r\n  path: \"/hello\",\r\n  f: () => \"hello World!\",\r\n});\r\n\r\n// Returning a `Response`\r\nconst ping = petitions.common()({\r\n  path: \"/ping\",\r\n  f: () => new Response(\"pong\"),\r\n});\r\n\r\nconsole.log(\r\n  helloWorld\r\n)\r\n```\r\n\r\nNotice that even if you specify only `path` and `f`, the log output is:\r\n\r\n```javascript\r\n  {\r\n    path: \"/hello\",\r\n    f: [Function: f],\r\n    type: \"base\",\r\n    o: undefined,\r\n    ... // More in the future\r\n  }\r\n```\r\n\r\nThis level of consistency in Vixeny’s architecture ensures that all petitions work seamlessly across different versions right out of the box! This design choice not only simplifies development but also enhances maintainability and scalability.\r\n\r\n### Reusability\r\n\r\nVixeny also offers two special petitions, `resolve` and `branch`, which we'll delve into later. For now, here's a quick look at what you can do:\r\n\r\n\r\n<Tabs data={tab0}/>\r\n\r\nIn practice, you'll rarely need to manually declare petitions like this. Instead, our `wrap` feature simplifies handling petitions and integrating all our tools.\r\n\r\n\r\n## Wrap\r\n\r\n\r\nThe `wrap` function in Vixeny is a pure function meticulously designed to the handling and manipulation of petitions. With `wrap`, you can:\r\n\r\n- **Avoid side effects** to ensure your code remains clean and predictable.\r\n- **Test or mock** the entire wrap or individual petitions.\r\n- **Debug on the spot**, Checking issues with just a line of code.\r\n- **Deploy your application** efficiently with built-in support.\r\n- **And much more...**\r\n\r\n<Tabs data={tab1}/>\r\n\r\nWhile this section acts more as a showcase, you can delve deeper and see `wrap` in action with examples of each method here:\r\n\r\n[Explore `wrap` Examples.](/library/wrap/)\r\n\r\n### Testing\r\n\r\nVixeny can be tested without the need for a `serve`, allowing for individual or\r\ncomprehensive testing of wraps:\r\n\r\n<Tabs data={tab3}/>\r\n\r\n### Mocking\r\n\r\nSupports testing individual petitions by injecting values while\r\npreserving their structure:\r\n\r\n```javascript\r\nimport { wrap } from \"vixeny\";\r\n\r\nconst request = new Request(\"http://localhost/one\");\r\n\r\nconst paths = wrap()().stdPetition({\r\n  path: \"/one\",\r\n  f: (c) => c.date.toString(),\r\n});\r\n\r\n// Handling the request without modifications\r\nconst handles = paths.handleRequest(\"/one\")({});\r\n\r\n// Handling the request with a mock date injected\r\nconst mocked = paths.handleRequest(\"/one\")({\r\n  options: {\r\n    setDate: 1710592645075,\r\n  },\r\n});\r\n\r\n// Outputs the current date\r\nconsole.log(await handles(request).then((r) => r.text()));\r\n\r\n// Outputs the mocked date: \"1710592645075\"\r\nconsole.log(await mocked(request).then((r) => r.text()));\r\n```\r\n\r\nVixeny is fully typed, with JSDoc examples provided for ease of use. Hover over\r\nthe code in your IDE to check.\r\n\r\n\r\n## Resolution\r\n\r\nUnlike traditional frameworks that rely on life cycles for code execution and\r\nrendering management, Vixeny employs a concept called \"resolution.\" A resolution\r\nis defined as:\r\n\r\n> A resolution involves chaining the resolution of any morphism (petition) by its resolve.\r\n\r\nStill wondering what that means? In simpler terms, anything defined with a `resolve` must be fully resolved before its caller can access it. This creates a chain of dependencies that are resolved in sequence.\r\n\r\n## Morphism\r\n\r\nAt the heart of Vixeny lies a fundamental type known as a \"Morphism.\" While this concept is abstracted away to keep things simple. Essentially, anything with an `f` (a functor) is considered a \"Morphism\", and for simpicity, we will bundle both terms as `petition`.\r\n\r\n\r\n```javascript\r\n\r\nimport { petitions, wrap } from \"vixeny\";\r\n\r\nconst request = new Request(\"http://localhost/\");\r\n\r\nconst nested = petitions.resolve()({\r\n  f: () => \"hello\",\r\n});\r\n\r\n\r\nconst handler = wrap()()\r\n    .stdPetition({\r\n        path: '/',\r\n        resolve: {\r\n            // Nested resolve\r\n            nested,\r\n          },\r\n          f: (f) => f.resolve.nested,\r\n    })\r\n    // Creates a handler\r\n    .compose()\r\n\r\nconsole.log(\r\n  //hello\r\n  handler(request),\r\n);\r\n```\r\n\r\n> Any `resolve` or `branch` can be utilized within a `Morphism`, but there are\r\n> not considered `petitions`, meaning, you can not use them directly in a\r\n> `wrap`.\r\n\r\nLet's break it down with more examples.\r\n\r\n## Resolve Properties\r\n\r\nVixeny's resolution mechanism ensures that data dependencies are resolved before\r\nthe main function is executed (Basically an import for the ctx). Simplifying asynchronous data handling and\r\ncomposition. Below, we explore key properties of resolution in Vixeny.\r\n\r\n### Resolves\r\n\r\nThe resolution process guarantees that all necessary data is fetched and\r\navailable for use within your petitions.\r\n\r\n```javascript\r\nimport { wrap } from \"vixeny\";\r\n\r\nconst request = new Request(\"http://localhost/\");\r\n\r\nconst handler = wrap()().stdPetition({\r\n  path: \"/withResolve\",\r\n  resolve: {\r\n    hi: { f: () => \"Hello world\" },\r\n  },\r\n  f: (ctx) => ctx.resolve.hi,\r\n})\r\n.compose();\r\n\r\n\r\nconsole.log(\r\n  handler(request),\r\n);\r\n```\r\n\r\n### SyncAgnostic\r\n\r\nVixeny's design ensures that the signature of your functor (function), `f`,\r\nremains unaffected by whether its dependencies, declared in `resolve`, are\r\nsynchronous or asynchronous. This allows for greater flexibility and simplicity, \r\nspecially when it comes to testing:\r\n\r\n```javascript\r\nimport { wrap } from \"vixeny\";\r\n\r\nconst hello = petitions.resolve()(\r\n  { f: async () => await Promise.resolve(\"Hello\") },\r\n);\r\n\r\nwrap(options)().stdPetition({\r\n  path: \"/helloWorld\",\r\n  resolve: {\r\n    // Adding `hello`.\r\n    hello,\r\n    // Everything in vixeny is nameless and stateless by nature.\r\n    world: { f: () => \"world\" },\r\n  },\r\n  // Important to notice that `f` is synchronous even if the resolve `hello` is not.\r\n  f: (ctx) => `${ctx.resolve.hello} ${ctx.resolve.world}`,\r\n});\r\n\r\n```\r\n\r\n### Mockable\r\n\r\nThis design also simplifies the process of mocking dependencies for testing\r\npurposes, where we do not need to make the call to test the behaviour, as shown below:\r\n\r\n<Tabs data={tab4}/>\r\n\r\n### Composable and Reusable\r\n\r\nThe resolution mechanism allows for the reuse and on-the-fly modification of any\r\nmorphism, making your code more modular and maintainable:\r\n\r\n```javascript\r\nimport { wrap , petitions } from 'vixeny';\r\n\r\n// Setting up a resolution\r\nconst sayHello = petitions.resolve()({\r\n  f: () => \"hello\",\r\n});\r\n\r\n// Creating a petition\r\nconst hey = petitions.common()({\r\n  path: \"/hey\",\r\n  resolve: {\r\n    sayHello,\r\n  }\r\n  f: ({ resolve }) => `${resolve.sayHello} World!`,\r\n});\r\n\r\nconst serve = wrap(options)()\r\n  .addAnyPetition(hey)\r\n```\r\n\r\n> This feature underscores the importance of utilizing `morphism` to ensure type\r\n> safety within your functions.\r\n\r\n\r\n<FancyLink href=\"/framework/routing\">Next</FancyLink>\r\n\r\n\r\n"
  },
  {
    "url": "/framework/routing",
    "content": "<script>\r\n\r\n    import Tabs from \"$lib/components/Tabs.md\"\r\n    import Bash from \"$lib/components/SmallComponents/Bash.md\"\r\n    import example0 from \"$lib/examples/intro_core_0.md\"\r\n    import FancyLink from '$lib/components/FancyLink.svelte';\r\n\r\n    const tab0 = [\r\n        {title: \"main.ts\", component: example0, details: {runtime: \"main\"}},\r\n        {title: \"setup.ts\", component: example0, details: {runtime: \"setup\"}}\r\n    ]\r\n\r\n</script>\r\n\r\n<svelte:head>\r\n    <title>Routing - Vixeny Framework</title>\r\n    <meta name=\"description\" content=\"Learn about routing in the Vixeny framework. Understand pathing, priorities, handling trailing slashes, and static file handling with comprehensive examples.\" />\r\n    <meta name=\"keywords\" content=\"Vixeny, routing, web development, pathing, priorities, trailing slashes, static file handling, JavaScript, TypeScript, petitions, wrap function\" />\r\n    <meta name=\"author\" content=\"Vixeny Team\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\r\n    <script src='/prism.mjs' defer></script>\r\n</svelte:head>\r\n\r\n# Routing\r\n\r\nThis lesson will be brief, yet it is crucial for understanding the logic of\r\npathing in Vixeny. We'll explore the granular power you have to manipulate your\r\ncode. It's important to grasp these basic concepts before we dive deeper into\r\n`composing` and incorporating these ideas anywhere.\r\n\r\n## Pathing\r\n\r\n We can create an `union` between two wraps \r\nand also modify their base using `startswith`.\r\n\r\n```ts\r\nimport { plugins, wrap } from \"vixeny\";\r\n\r\n// Setting up options\r\nconst api = plugins.globalOptions({\r\n  wrap: {\r\n    startWith: \"/api\",\r\n  },\r\n});\r\n\r\n// Creating a wrap\r\nconst apiWrap = wrap(api)()\r\n  .stdPetition({\r\n    path: \"/hello\",\r\n    f: () => \"api\",\r\n  });\r\n\r\n// Merging the paths\r\nconst root = wrap()(\r\n  // You can also unwrap it in the constructor\r\n  // apiWrap.unwrap(),\r\n  )\r\n  .union(apiWrap.unwrap())\r\n  .stdPetition({\r\n    path: \"/\",\r\n    f: () => \"main\",\r\n  })\r\n  //  ` /  `\r\n  //  ` /api/hello  `\r\n  .logPaths();\r\n```\r\n\r\nThis helps manage the complexity of routing by providing an easy way to export and import `petitions`. Moreover, since `wrap` has a  monadic structure (A programming concept that helps manage workflows by allowing functions to chain operations in a sequence, while ensuring each operation is isolated from others), importing, testing, or modifying any wrap cannot affect other instances. This behavior will be explained further in the `wrap` section of the library.\r\n\r\n## Priority\r\n\r\nWe fully support wildcards `/path/*` using the following order:\r\n\r\n- Real paths (e.g., `/`, `/user`, `/user/:id`)\r\n- Wildcards and static files (e.g., `/static/html/*` -> `/static/*` -> `/*`)\r\n\r\nThis means that `real paths` are prioritized over wildcards, which reflect other\r\nnested wildcards.\r\n\r\n## At\r\n\r\nThis option allows us to move the `baseIndex` to a specific directory. Now, you\r\nmight be wondering why we need this feature. We will explore its utility in more\r\ndepth during the `extending` section after `composing`, but it is important to\r\nknow that you can rebase the logic of your routing `at` any level.\r\n\r\n```ts\r\nimport { plugins, wrap } from \"vixeny\";\r\n\r\n// Requests\r\nconst atIndex = new Request(\"http://localhost/hello\");\r\nconst atFourBar = new Request(\"http://localhost/bar/hello\");\r\nconst atIndexFoo = new Request(\"http://localhost/foo/hello\");\r\n\r\n// Setting up options\r\nconst opt = plugins.globalOptions({\r\n  indexBase: {\r\n    at: 4,\r\n  },\r\n});\r\n\r\n// Making a wrap\r\nconst app = wrap()()\r\n  .stdPetition({\r\n    path: \"/hello\",\r\n    f: () => \"world\",\r\n  });\r\n\r\n// Note that we are using the same `app`, all instance of wrap are immutable\r\n\r\n// Testing the wrap\r\nconst handler = app\r\n  .testRequests();\r\n\r\n// Testing the wrap with the options\r\nconst atFourhandler = app\r\n  // Adding the options\r\n  .changeOptions(opt)\r\n  .testRequests();\r\n\r\n// Expected behavior of the handler\r\nconsole.log(\r\n  // true\r\n  (await handler(atIndex)).status === 200,\r\n  // true\r\n  (await handler(atFourBar)).status === 404,\r\n);\r\n\r\n// Checking the request status after moving the handler one directory deeper\r\n\r\nconsole.log(\r\n  // true\r\n  (await atFourhandler(atIndex)).status === 404,\r\n  // true\r\n  (await atFourhandler(atFourBar)).status === 200,\r\n);\r\n```\r\n\r\n## Trailing slashes\r\n\r\nBy default, `/hello` and `/hello/` are not the same path but this can easily can\r\nbe change with `strictTrailingSlash`.\r\n\r\n```ts\r\nconst req = new Request(\"http://localhost/hello\");\r\nconst trailingSlash = new Request(\"http://localhost/hello/\");\r\n\r\nconst opt = plugins.globalOptions({\r\n  router: {\r\n    // When set to false, /hello and /hello/ will be treated as the same route\r\n    strictTrailingSlash: false,\r\n  },\r\n});\r\n\r\nconst app = wrap()()\r\n  .stdPetition({\r\n    path: \"/hello\",\r\n    f: () => \"world\",\r\n  });\r\n\r\n// Note that we are using the same `app`, all instance of wrap are immutable\r\n\r\nconst strictSlashTests = app\r\n  .testRequests();\r\n\r\nconst flexibleSlashTests = app\r\n  .changeOptions(opt)\r\n  .testRequests();\r\n\r\nconsole.log(\r\n  // Testing without the flexible slash option\r\n\r\n  // Expected to be 200, /hello is defined\r\n  (await strictSlashTests(req)).status === 200,\r\n  // Expected to be 404, /hello/ is not defined when strict\r\n  (await strictSlashTests(trailingSlash)).status === 404,\r\n);\r\n\r\nconsole.log(\r\n  // Testing with the flexible slash option enabled\r\n\r\n  // Expected to be 200, /hello is defined\r\n  (await flexibleSlashTests(req)).status === 200,\r\n  // Expected to be 200, /hello/ is treated the same as /hello\r\n  (await flexibleSlashTests(trailingSlash)).status === 200,\r\n);\r\n```\r\n\r\n## Static File Handling\r\n\r\nIn web development, serving static files (like images, scripts, and stylesheets)\r\nis a common requirement. Vixeny simplifies this process with built-in support\r\nfor static file serving.\r\n\r\nConsider a scenario where you want to serve a simple `package.json` file from\r\nthe root directory of your project. Here’s how you can set up Vixeny to handle\r\nthis:\r\n\r\n```ts\r\nimport { composeResponse, petitions, plugins } from \"vixeny\";\r\n\r\n// Define a basic response\r\nconst helloWorld = petitions.common()({\r\n  path: \"/\",\r\n  f: () => \"hello world!\",\r\n});\r\n\r\n// Create a request for a static file\r\nconst req = new Request(\"http://localhost/package.json\");\r\n\r\n// Compose the response handler with static file support\r\nconst handler = composeResponse()([\r\n  helloWorld,\r\n  plugins.fileServer({\r\n    type: \"fileServer\",\r\n    // Specifies the directory from which files will be served,\r\n    // relative to the directory where the server was started.\r\n    path: \"./\",\r\n    // Base directory path on the server under which files will be accessible\r\n    name: \"/\",\r\n    // Disables automatic MIME type detection to allow more granular control if required\r\n    mime: false,\r\n  }),\r\n]);\r\n\r\n// Fetching the package.json file\r\nconsole.log(\r\n  await Promise\r\n    .resolve(handler(req))\r\n    .then((x) => x.text()),\r\n);\r\n```\r\n\r\n---\r\n\r\n<FancyLink href=\"/framework/composing\">Next</FancyLink>\r\n"
  },
  {
    "url": "/framework/composing",
    "content": "<script>\r\n  import FancyLink from '$lib/components/FancyLink.svelte';\r\n</script>\r\n\r\n<svelte:head>\r\n  <script src='/prism.mjs' defer></script>\r\n  <title>Morphism - Vixeny Framework</title>\r\n  <meta name=\"description\" content=\"Understanding morphism in the Vixeny framework. Learn how to create and compose petitions and resolves for effective routing and functional programming.\" />\r\n  <meta name=\"keywords\" content=\"Vixeny, morphism, routing, web development, petitions, composer, JavaScript, TypeScript, functional programming, web framework\" />\r\n  <meta name=\"author\" content=\"Vixeny Team\" />\r\n\r\n</svelte:head>\r\n\r\n# Composing\r\n\r\nNow that we know how to create routes and have some insights into what we can\r\ndo, let's discuss `petitions` and `composer` and explore why they exist.\r\n\r\nThe TL;DR is that `petitions` create `morphic objects` that maintain structure\r\nacross versions, think about it as an abstract route. You can link these objects\r\ntogether like Legos, and also compose them into functional units with `composer`\r\nto use within Vixeny or wherever else they may be needed.\r\n\r\n```ts\r\nimport { composer, petitions } from \"vixeny\";\r\n\r\nconst req = new Request(\"http://localhost/\");\r\n\r\n// Creating a resolve\r\nconst getHello = petitions.resolve()({\r\n  f: () => \"hello\",\r\n});\r\n\r\n// Creating a Petition\r\nconst response = petitions.standard()({\r\n  // This function is the endpoint for the request\r\n  path: \"/THIS_FUNCTION_DOES_HAVE_A_ROUTER\",\r\n  resolve: {\r\n    getHello,\r\n  },\r\n  f: ({ resolve }) => new Response(resolve.getHello),\r\n});\r\n\r\n// Composing the Petition\r\nconst composedPetition = composer.petition(response);\r\n\r\n// Composing the Resolve\r\nconst composedResolve = composer.anyRequest()(getHello);\r\n\r\nconsole.log(\r\n  // Outputs \"hello\"\r\n  composedResolve(req),\r\n  // Returns true\r\n  composedResolve(req) ===\r\n    await Promise\r\n      .resolve(composedPetition(req))\r\n      .then((res) => res.text()),\r\n);\r\n```\r\n\r\nYou will find a detailed explanation of them in `library`.\r\n\r\n\r\n## Types\r\n\r\nVixeny allows different types of petition handling to suit various application\r\nneeds. Here, we demonstrate the use of `custom` and `standard` petitions, as\r\nwell as a simplified approach that does not use the context object (`CTX`).\r\n\r\n- **Custom Petition (costume)**: The headers are dynamically passed and set\r\n  based on petition configurations and the provided options.\r\n- **Standard Petition (common)**: Utilizes a predefined response format. Note\r\n  that headers are set statically and cannot be altered dynamically within the\r\n  function.\r\n- **Petition Without CTX (response)**: This type bypasses the use of the\r\n  `composer`, offering a straightforward way to return responses with predefined\r\n  headers.\r\n\r\nLet's add some CORS settings and see these petitions in action:\r\n\r\n```ts\r\nimport { plugins, wrap } from \"vixeny\";\r\n\r\nconst opt = plugins.globalOptions({\r\n  cors: {\r\n    allowOrigins: \"*\",\r\n    allowMethods: [\"GET\"],\r\n  },\r\n});\r\n\r\nconst handler = wrap(opt)()\r\n  .customPetition({\r\n    path: \"/custom\",\r\n    headings: {\r\n      headers: \"text/html\",\r\n    },\r\n    f: ({ headers }) =>\r\n      new Response(\"<p>Hello World!</p>\", {\r\n        headers,\r\n      }),\r\n  })\r\n  .stdPetition({\r\n    path: \"/std\",\r\n    headings: {\r\n      headers: \"text/html\",\r\n    },\r\n    // Headers are fixed; there's no way to change them dynamically\r\n    f: () =>\r\n      new Response(\"<p>Hello World!</p>\", {\r\n        headers: new Headers([\r\n          [\"Content-Type\", \"text/html\"],\r\n        ]),\r\n      }),\r\n  })\r\n  .petitionWithoutCTX({\r\n    path: `/response`,\r\n    r: () =>\r\n      new Response(\"<p>Hello World!</p>\", {\r\n        headers: new Headers([\r\n          [\"Content-Type\", \"text/html\"],\r\n        ]),\r\n      }),\r\n  }).testRequests();\r\n\r\n// Helper functions\r\nconst requestOf = (s: string) => new Request(s);\r\nconst logHead = (r: Response) => void console.log(r.headers);\r\n\r\n// Results\r\nawait handler(requestOf(\"http://localhost/std\"))\r\n  .then(logHead);\r\nawait handler(requestOf(\"http://localhost/custom\"))\r\n  .then(logHead);\r\nawait handler(requestOf(\"http://localhost/response\"))\r\n  .then(logHead);\r\n```\r\n\r\nIt's important to note that `petitionWithoutCTX` and `petitions.response` do not\r\nhave a `CTX` and are not composed like other functions. This isolation of code,\r\ntypically done with `at`, will be covered in the `extending` section.\r\n\r\n## Composer\r\n\r\nThe `composer` in Vixeny plays a crucial role by overseeing the `ctx` within\r\nfunctions, composing petitions and `branch`, chaining `resolve`, and efficiently\r\nhandling both asynchronous and synchronous operations. But what exactly does\r\nthis entail? Let's delve into the concept of `ctx` and its role.\r\n\r\n### Native components\r\n\r\nHere a list of all the methods availiable.\r\n\r\nPlugins are not listed:\r\n\r\n- **args:** Passes the arguments to the current CTX when a `branch` is composed.\r\n- **resolve:** Gets the values of the resolved functions.\r\n- **branch:** Gets access to the functions in `branch`.\r\n- **req:** Direct access to the HTTP request object.\r\n- **query:** Facilitates easy access to URL query parameters.\r\n- **param:** Extracts URL path parameters.\r\n- **headers:** Provides access to HTTP request headers (Only for costume\r\n  petitions).\r\n- **date:** Offers access to the current timestamp.\r\n- **cookie:** Manages HTTP cookies.\r\n- **io:** Handles file operations.\r\n\r\nIf `crypto` with at least a `globalKey` is present.\r\n\r\n- **sign:** Gives access to a sign function.\r\n- **verify:** Gives access to a verify function.\r\n- **token:** Verifies the cookies with the current key.\r\n\r\n## Debugging\r\n\r\nYou can check and see what the comper will do at any moment with `debugLast`,\r\nadding an extra layer of transparency.\r\n\r\n```typescript\r\nimport { wrap } from \"vixeny\";\r\n\r\nexport default wrap()()\r\n  .stdPetition({\r\n    path: \"/\",\r\n    f: () => \"helloWorld\",\r\n  })\r\n  // Console logging: []\r\n  .debugLast()\r\n  .stdPetition({\r\n    path: \"/hello/:id\",\r\n    f: (c) => c.param.id,\r\n  })\r\n  // Console logging: [\"param\"]\r\n  .debugLast();\r\n```\r\n\r\n## Add, Remove and Only\r\n\r\nThe composer analyzes your petitions and selectively adds only the necessary\r\nelements to the `CTX`. This process ensures optimal performance and cleaner code\r\nby avoiding unnecessary inclusions. However, the optimizer's automated nature\r\nmeans it might not automatically include external function requirements. You can\r\nmanually specify these as needed:\r\n\r\n```typescript\r\nimport { wrap } from \"vixeny\";\r\n\r\nconst functionOutsideOfContext = <T extends Object>(ctx: T) =>\r\n  Object.keys(ctx)\r\n    .toString();\r\n\r\nexport default wrap()()\r\n  .stdPetition({\r\n    path: \"/hello/query1\",\r\n    f: (c) => functionOutsideOfContext(c),\r\n  })\r\n  // Console logging: []\r\n  .debugLast()\r\n  .stdPetition({\r\n    path: \"/hello/query2\",\r\n    f: (c) => functionOutsideOfContext(c),\r\n    options: {\r\n      add: [\"query\"],\r\n    },\r\n  })\r\n  // Console logging: [\"query\"]\r\n  .debugLast();\r\n```\r\n\r\nCustomization options include `only`, which bypasses the optimizer to add only\r\nspecified functions; `add`, which includes additional functions; and `remove`,\r\nwhich excludes.\r\n\r\n<FancyLink href=\"/framework/extending\">Next</FancyLink>\r\n"
  },
  {
    "url": "/framework/extending",
    "content": "<script>\r\n\r\n  import FancyLink from '$lib/components/FancyLink.svelte';\r\n</script>\r\n\r\n<svelte:head>\r\n\r\n<title>Extending - Vixeny</title>\r\n<script src='/prism.mjs' defer></script>\r\n<meta name=\"description\" content=\"Adding elements together\" />\r\n</svelte:head>\r\n\r\n# Extending\r\n\r\n// Intro\r\n\r\n## Enclosing\r\n\r\nEnclosing in Vixeny allows you to nest wraps, other frameworks and functions\r\nwithin other wraps, effectively creating a clousere that the current wrap can't\r\naccess to.\r\n\r\n```ts\r\n// Making a wrap with a specific index base set at the fourth segment\r\nconst handlerAt4 = wrap({\r\n  indexBase: {\r\n    at: 4,\r\n  },\r\n})()\r\n  .stdPetition({\r\n    path: \"/foo\",\r\n    f: () => \"from inside\",\r\n  })\r\n  .stdPetition({\r\n    path: \"/foo/:hello\",\r\n    f: ({ param }) => param.hello,\r\n  })\r\n  .compose();\r\n\r\n// Making a handler that includes the wrap within a broader path context\r\nconst handler = wrap()()\r\n  .petitionWithoutCTX({\r\n    path: \"/bar/*\", // Encloses \"wrapAt4\" within the \"/bar\" path\r\n    r: handlerAt4,\r\n  }).testRequests();\r\n\r\nconst base = \"http://localhost/bar\";\r\nconst req = new Request(base + \"/foo\");\r\nconst param = new Request(base + \"/foo/param\");\r\n\r\n// Executing and logging the response from the \"/foo\" route\r\nawait handler(req).then((x) => x.text())\r\n  // Expected to log \"from inside\"\r\n  .then(console.log);\r\nawait handler(param)\r\n  .then((x) => x.text())\r\n  // Expected to log \"param\"\r\n  .then(console.log);\r\n```\r\n\r\n## Plugins\r\n \r\n // Comming soon.\r\n\r\n## Exporting\r\n\r\n// Cooming soon.\r\n\r\nThanks for your time.\r\n"
  },
  {
    "url": "/perspective/create-vixeny",
    "content": "\r\n<script>\r\n  // Importing necessary components\r\n  import Tabs from \"$lib/components/Tabs.md\";\r\n  import Bash from \"$lib/components/SmallComponents/Bash.md\";\r\n  import plugin from \"$lib/examples/plugins_typebox.md\";\r\n  import Request from \"$lib/components/Request.svelte\"\r\n  // Array containing the installation options for the Tabs component\r\n  const install = [\r\n    { title: \"Bun\", component: Bash, details: { runtime: \"bun\" } },\r\n    { title: \"Deno\", component: Bash, details: { runtime: \"deno\" } }\r\n  ];\r\n  const tab0 = [\r\n      {title: \"main.ts\", component: plugin, details: {runtime: \"main\"}},\r\n      {title: \"setup.ts\", component: plugin, details: {runtime: \"setup\"}}\r\n  ];\r\n</script>\r\n\r\n<svelte:head>\r\n  <script src='/prism.mjs' defer></script>\r\n  <title>Introduction - Vixeny</title>\r\n  <meta name=\"description\" content=\"Using create-vixeny\"/>\r\n</svelte:head>\r\n\r\n\r\n# Welcome\r\nWelcome to vixeny templates! Here are some basics of how the template engine works, it's recommended to learn how the dynamic path system works, via the link below.\r\n\r\n>  [Dynamic routes](/framework/init)\r\n\r\n\r\n## Before We Start!\r\n\r\nWe will be using a second server hosted on `Deno Deploy` for the examples. You can ping the server here:\r\n\r\n<Request url=\"/ping\" displaysData={false} />\r\n\r\n**Disclaimers**\r\n\r\n- It's a free-tier host.\r\n- The first ping call is always slower due to the handshake with the server; the average ping is 55ms.\r\n\r\n\r\n\r\n\r\n## Introduction to Vixeny's Structure\r\n\r\nLet's dive into the structure briefly seeing how everything interacts.\r\n\r\n### File Structure\r\n\r\nThe structure of a typical Vixeny project after installation and template selection looks like this:\r\n\r\n```bash\r\n./\r\n├── main.ts\r\n├── package.json\r\n├── src/\r\n│   ├── globalOptions.ts\r\n│   ├── paths/\r\n│   │   └── root.ts\r\n│   └── plugins/\r\n│       ├── tsx.ts\r\n│       ├── typebox.ts\r\n│       └── typescript.ts\r\n├── tsconfig.json\r\n├── views/\r\n│   ├── public/\r\n│   │   ├── $main.tsx\r\n│   │   ├── css/\r\n│   │   │   ├── ...\r\n│   │   └── mjs/\r\n│   │       └── main.ts\r\n│   └── scripts/\r\n│       └── addFooter.ts\r\n└── watcher.mjs\r\n```\r\n\r\n### Explanation of Key Files and Directories\r\n\r\n1. **main.ts**: The main entry point of the server.\r\n2. **src**: Contains all the dynamic routes.\r\n   - **paths**: Houses the logical routes.\r\n   - **plugins**: Contains addons and templates.\r\n   - **globalOptions.ts**: Holds options for `wrap` and the `handler`.\r\n3. **views**: Contains static templates.\r\n   - **public**: Exposes all files for public access.\r\n   - **scripts**: Manages TypeScript `ts` files, which are then imported into public to convert to `mjs`.\r\n4. **watcher.mjs**: The debugger script.\r\n\r\n### Current Options\r\n\r\nTemplates work by pointing at a directory and hosting it to the handler, it's   important to remark that:\r\n\r\n - They respect nested wildcards.\r\n - The handler can have more than one.\r\n\r\nThe next example assumes that you only installed `pug`.\r\n\r\n```javascript\r\nconst fileServer = plugins.fileServer({\r\n  type: \"fileServer\",\r\n  // Hosted on \r\n  name: \"/\",\r\n  // Takes files from \r\n  path: \"./views/public/\",\r\n  // Removes extensions of \r\n  removeExtensionOf: [\".html\"],\r\n  // If a file starts with it, it will become the `/` of the directory\r\n  slashIs: \"$main\",\r\n  // Current templates in use:\r\n  template: [pugP,typescriptP]\r\n});\r\n```\r\nYou can find this file at `src/globalOptions.ts`.\r\n\r\n### Plugins and Templates\r\n\r\n#### Example of Using Typebox plugin\r\n\r\nAs we know from the core introduction, plugins only exist if they are included in the `options`, here a basic implementation but by default all files are set up in `create-vixeny`.\r\n\r\nYou can find this file at `src/plugins`.\r\n\r\n<Tabs data={tab0}/>\r\n\r\n#### Example of Using Pug Template\r\n\r\nMost of the templates have a :  \r\n\r\n- `default`: Gives an object to all the templates for compilation. \r\n- `preserveExtension`: Removes the extension of the file. \r\n- `petition`: Enables a semi-static route using a petition for all the routes in the wildcard. \r\n\r\nIn the next example we will use pug so, let's create a file called `hello.pug`.\r\n\r\n1. Create a `hello.pug` file:\r\n   ```pug\r\n   p #{name}'s Pug source code!\r\n   ```\r\n\r\n2. Install the `pug` package and set up `src/plugins/pug.ts`:\r\n   ```ts\r\n   import * as pugModule from \"pug\";\r\n   import { plugins , composeResponse } from \"vixeny\";\r\n   import { pugStaticServerPlugin } from \"vixeny-perspective\";\r\n\r\n   const serve = composeResponse()([\r\n     {\r\n       type: \"fileServer\",\r\n       name: \"/\",\r\n       path: \"./public/\",\r\n       template: [\r\n         pugStaticServerPlugin(\r\n           pugModule.compileFile\r\n         )({\r\n           preserveExtension: false,\r\n           // Default case\r\n           default: {\r\n             name: 'avant'\r\n           }\r\n         }),\r\n       ],\r\n     },\r\n   ]);\r\n   ```\r\n\r\n3. Fetch the rendered page:\r\n\r\n<Request url=\"/hello\" displaysData={false} />\r\n\r\n\r\n\r\n### Semi-Static Routes\r\n\r\nAs we saw in the last example, you can have a default case but vixeny's structure also allows you to have a petition for the whole `staticFileServe`.\r\n\r\n#### Using `composer.objectNullRequest`\r\n\r\n1. Create a petition that checks for a query parameter:\r\n\r\nTo do this we need composer.objectNullRequest , where if this petition returns null it will return the default case, otherwise it will pass the object to the template.\r\n\r\n   ```javascript\r\n   import { composer } from \"vixeny\";\r\n\r\n   const petition = composer.objectNullRequest()({\r\n    // If query.name exist, it returns the object query, otherwhise it returns null\r\n     f: ({ query }) => \r\n       query?.name \r\n          ? query \r\n          : null\r\n   });\r\n   ```\r\n2. Modify `pugStaticServerPlugin` to use the petition:\r\n   ```ts\r\n   import { pugStaticServerPlugin } from \"vixeny-perspective\";\r\n   import { composer } from \"vixeny\";\r\n   import * as pugModule from \"pug\";\r\n\r\n   export default pugStaticServerPlugin(pugModule.compileFile)({\r\n     preserveExtension: false,\r\n     default: { name: 'avant' },\r\n     petition: composer.objectNullRequest()({\r\n       f: ({ query }) => \r\n         query?.name \r\n         ? query \r\n         : null\r\n     })\r\n   });\r\n   ```\r\n\r\n#### Fetching with and without a Query Parameter\r\n\r\n\r\n\r\n\r\n- Default:\r\n\r\n<Request url=\"/hello\" displaysData={true} />\r\n\r\n- With a query parameter:\r\n\r\n\r\n<Request url=\"/hello?name=dave\" displaysData={true} />\r\n\r\nYou can find this file at `src/plugins`."
  },
  {
    "url": "/plugins/native",
    "content": "//TODO\r\n\r\n\r\n- [Typebox ☑️](/plugins/native/typebox)"
  },
  {
    "url": "/about/questions",
    "content": "# Hello\r\n\r\n// TODO\r\n\r\n## Questions\r\n\r\n// TODO"
  }
]
